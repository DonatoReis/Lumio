import { useState, useEffect, useCallback, useRef, useReducer } from 'react';
import { supabase, safeQuery } from '@/integrations/supabase/client';
import { ConversationWithParticipants, Profile, Database } from '@/types/supabase';
import { useAuth } from '@/contexts/AuthContext';
import { useToast } from '@/hooks/use-toast';
import { v4 as uuidv4 } from 'uuid';
import { normalizeEmail, isValidEmail } from '@/utils/email-validator';

// Debug flag for controlling log verbosity
const DEBUG = false;

// Reconnection parameters
const INITIAL_DELAY = 5000; // 5 seconds
const MAX_DELAY = 120000; // 2 minutes
const BACKOFF_MULTIPLIER = 2;
const JITTER_RANGE = 1000; // +/- 1 second jitter
const MAX_RECONNECT_ATTEMPTS = 5;
const CIRCUIT_BREAKER_RESET_TIMEOUT = 60000; // 1 minute
const WEBSOCKET_PING_INTERVAL = 30000; // 30 seconds

// Circuit breaker states
type BreakerState = 'CLOSED' | 'HALF_OPEN' | 'OPEN';

// Circuit breaker reducer state
interface BreakerReducerState {
  breaker: BreakerState;
  failureCount: number;
  lastFailureTime: number | null;
}

// Circuit breaker actions
type BreakerAction =
  | { type: 'FAIL' }
  | { type: 'SUCCESS' }
  | { type: 'RESET' }
  | { type: 'HALF_OPEN' };

// Log throttling
let lastLogTime: Record<string, number> = {};

// Throttled logging function to reduce console verbosity
function throttledLog(key: string, message: string, level: 'log' | 'warn' | 'error' = 'log', minInterval = 60000) {
  const now = Date.now();
  if (!lastLogTime[key] || (now - lastLogTime[key] > minInterval)) {
    if (DEBUG || level !== 'log') {
      console[level](`[useConversations] ${message}`);
    }
    lastLogTime[key] = now;
    return true;
  }
  return false;
}

// Calculate backoff delay with jitter
function getBackoffDelay(attempt: number): number {
  const baseDelay = Math.min(INITIAL_DELAY * Math.pow(BACKOFF_MULTIPLIER, attempt), MAX_DELAY);
  const jitter = Math.random() * JITTER_RANGE * 2 - JITTER_RANGE; // +/- JITTER_RANGE
  return baseDelay + jitter;
}

// Circuit breaker reducer function
function breakerReducer(state: BreakerReducerState, action: BreakerAction): BreakerReducerState {
  switch (action.type) {
    case 'FAIL':
      const failures = state.failureCount + 1;
      if (failures >= MAX_RECONNECT_ATTEMPTS) {
        return { 
          breaker: 'OPEN', 
          failureCount: failures,
          lastFailureTime: Date.now()
        };
      }
      return { 
        ...state, 
        failureCount: failures,
        lastFailureTime: Date.now()
      };
    case 'SUCCESS':
      return { 
        breaker: 'CLOSED', 
        failureCount: 0,
        lastFailureTime: null
      };
    case 'HALF_OPEN':
      return { 
        breaker: 'HALF_OPEN', 
        failureCount: state.failureCount,
        lastFailureTime: null
      };
    case 'RESET':
      return { 
        breaker: 'CLOSED', 
        failureCount: 0,
        lastFailureTime: null
      };
    default:
      return state;
  }
}

// Define specific interfaces to replace 'any' types
interface ConversationParticipant {
  conversation_id: string;
  user_id: string;
  id?: string;
}

interface ConversationData {
  id: string;
  name: string | null;
  created_at: string;
  updated_at: string;
  [key: string]: any; // For other properties
}

interface MessageData {
  id: string;
  conversation_id: string;
  sender_id: string;
  content: string;
  created_at: string;
  read?: boolean;
  [key: string]: any; // For other properties
}

// Support type for RPC functions that return strings
type RPCReturnType = string | number | boolean | object | null;

// Define a type for user conversation preferences
interface UserConversationPreference {
  id: string;
  user_id: string;
  conversation_id: string;
  is_muted: boolean;
  is_pinned: boolean;
  is_archived: boolean;
  is_deleted: boolean;
  messages_cleared_at?: string;
  created_at: string;
  updated_at: string;
}

// Type assertion helper functions to fix TS errors
function fromTable<T = any>(tableName: string) {
  return supabase.from(tableName as any) as any;
}

function callRPC<TResult = any, TParams extends Record<string, any> = {}>(
  functionName: string,
  params?: TParams
): Promise<{ data: TResult; error: any }> {
  return supabase.rpc(functionName as any, params) as any;
}

export const useConversations = () => {
  const [conversations, setConversations] = useState<ConversationWithParticipants[]>([]);
  const [loading, setLoading] = useState(true);
  const [connectionStatus, setConnectionStatus] = useState<'OPEN' | 'CLOSED' | 'ERROR'>('CLOSED');
  const { user } = useAuth();
  const { toast } = useToast();
  
  // Circuit breaker state
  const [{ breaker, failureCount, lastFailureTime }, dispatchBreaker] = useReducer(breakerReducer, {
    breaker: 'CLOSED',
    failureCount: 0,
    lastFailureTime: null
  });
  
  // Refs for cleanup
  const timeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);
  const pingIntervalRef = useRef<ReturnType<typeof setInterval> | null>(null);
  const breakerTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);
  
  // Refs for subscriptions
  const subscriptionsRef = useRef<Record<string, any>>({});

  const fetchConversations = useCallback(async () => {
    if (!user) return;
    
    try {
      setLoading(true);
      
      // Use safeQuery with arrow function properly
      const { data: conversationParticipants, error: participantsError } = await safeQuery<ConversationParticipant[]>(
        () => supabase
          .from('conversation_participants')
          .select('conversation_id')
          .eq('user_id', user.id),
        'fetching conversation participants'
      );
          
      if (participantsError) {
        throw participantsError;
      }
      
      // Use optional chaining and nullish coalescing to safely handle data
      const participantsArray = conversationParticipants || [];
      if (participantsArray.length === 0) {
        setConversations([]);
        setLoading(false);
        return;
      }
      
      const conversationIds = participantsArray.map(p => p.conversation_id);
      
      // Fetch user conversation preferences to filter out deleted conversations
      const { data: userPreferences, error: preferencesError } = await safeQuery<UserConversationPreference[]>(
        () => fromTable<UserConversationPreference>('user_conversation_preferences')
          .select('conversation_id, is_deleted')
          .eq('user_id', user.id)
          .in('conversation_id', conversationIds),
        'fetching user conversation preferences'
      );
      
      if (preferencesError) {
        console.error("Error fetching user preferences:", preferencesError);
        // Continue without preference filtering if there's an error
      }
      
      // Filter out deleted conversations
      let filteredConversationIds = conversationIds;
      if (userPreferences && userPreferences.length > 0) {
        console.log("[useConversations] Found user preferences for conversations:", userPreferences.length);
        // Create a map of conversation_id to deleted status for quick lookups
        const deletedMap = userPreferences.reduce((acc, pref) => {
          if (pref.is_deleted) {
            acc[pref.conversation_id] = true;
          }
          return acc;
        }, {} as Record<string, boolean>);
        
        // Filter out deleted conversations
        filteredConversationIds = conversationIds.filter(id => !deletedMap[id]);
        console.log(`[useConversations] Filtered out ${conversationIds.length - filteredConversationIds.length} deleted conversations`);
      }
      
      if (filteredConversationIds.length === 0) {
        console.log("[useConversations] No non-deleted conversations found");
        setConversations([]);
        setLoading(false);
        return;
      }
      
      // Use safeQuery with arrow function properly
      const { data: conversationsData, error: conversationsError } = await safeQuery<ConversationData[]>(
        () => supabase
          .from('conversations')
          .select('*')
          .in('id', filteredConversationIds)
          .order('updated_at', { ascending: false }),
        'fetching conversations'
      );
          
      if (conversationsError) {
        throw conversationsError;
      }
      
      // For each conversation, fetch participants and last message
      const conversationsDataArray = conversationsData || [];
      const conversationsWithDetails = await Promise.all(conversationsDataArray.map(async (conversation) => {
        try {
          // Use safeQuery with arrow function properly
          const { data: participants, error: participantsError } = await safeQuery<ConversationParticipant[]>(
            () => supabase
              .from('conversation_participants')
              .select('user_id')
              .eq('conversation_id', conversation.id),
            `fetching participants for conversation ${conversation.id}`
          );
              
          if (participantsError) {
            throw participantsError;
          }
          
          const participantsArray = participants || [];
          const participantIds = participantsArray.map(p => p.user_id);
          
          // Use safeQuery with arrow function properly
          const { data: profiles, error: profilesError } = await safeQuery<Profile[]>(
            () => supabase
              .from('profiles')
              .select('*')
              .in('id', participantIds),
            `fetching profiles for conversation ${conversation.id}`
          );
              
          if (profilesError) {
            throw profilesError;
          }
          
          // Use safeQuery with arrow function properly
          const { data: messages, error: messagesError } = await safeQuery<MessageData[]>(
            () => supabase
              .from('messages')
              .select('*')
              .eq('conversation_id', conversation.id)
              .order('created_at', { ascending: false })
              .limit(1),
            `fetching messages for conversation ${conversation.id}`
          );
              
          if (messagesError) {
            throw messagesError;
          }
          
          const profilesArray = profiles || [];
          const messagesArray = messages || [];
          
          return {
            ...conversation,
            participants: profilesArray,
            lastMessage: messagesArray.length > 0 ? messagesArray[0] : undefined,
          };
        } catch (err) {
          console.error(`Error processing conversation ${conversation.id}:`, err);
          // Return a basic conversation object if there was an error
          return {
            ...conversation,
            participants: [],
            lastMessage: undefined
          };
        }
      }));
      
      setConversations(conversationsWithDetails);
    } catch (error) {
      console.error('Error fetching conversations:', error);
      const errorMessage = error instanceof Error ? error.message : "Could not load your conversations";
      toast({
        variant: "destructive",
        title: "Error loading conversations",
        description: errorMessage,
      });
    } finally {
      setLoading(false);
    }
  }, [user, toast]);

  // Schedule reconnection with backoff
  const scheduleReconnect = useCallback(() => {
    // Clean up any existing timeout
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
      timeoutRef.current = null;
    }
    
    // Don't schedule reconnect if circuit breaker is OPEN
    if (breaker === 'OPEN') {
      throttledLog('breaker-open', 'Circuit breaker OPEN - not scheduling reconnect', 'warn');
      return;
    }
    
    // Allow one attempt if breaker is HALF_OPEN
    if (breaker === 'HALF_OPEN') {
      throttledLog('half-open-reconnect', 'Circuit breaker HALF_OPEN - making single reconnect attempt', 'log');
      fetchConversations();
      return;
    }
    
    // Calculate delay based on failure count
    const delay = getBackoffDelay(failureCount);
    
    throttledLog(
      'reconnect-scheduled',
      `Reconnect scheduled in ${(delay/1000).toFixed(1)}s (attempt ${failureCount + 1}/${MAX_RECONNECT_ATTEMPTS})`,
      'log'
    );
    
    // Schedule reconnect
    timeoutRef.current = setTimeout(() => {
      throttledLog('reconnect-executing', 'Executing scheduled reconnect', 'log');
      fetchConversations();
      timeoutRef.current = null;
    }, delay);
  }, [breaker, failureCount, fetchConversations]);
  
  // WebSocket ping function to keep connection alive
  const sendPing = useCallback(async () => {
    if (!supabase || breaker === 'OPEN') return;
    
    try {
      // Simple RPC call that should be lightweight
      await supabase.rpc('ping_connection', {}).select();
      throttledLog('ping-success', 'Ping succeeded', 'log', 180000); // Log success occasionally
    } catch (err) {
      throttledLog('ping-error', `Ping failed: ${err instanceof Error ? err.message : 'Unknown error'}`, 'warn');
      
      // If ping fails, treat it as a connection failure
      dispatchBreaker({ type: 'FAIL' });
      
      // Schedule reconnect
      scheduleReconnect();
    }
  }, [breaker, scheduleReconnect]);
  
  // Handle connection status changes
  const handleConnectionStatus = useCallback((status: string, channel: string) => {
    throttledLog('connection-status', `${channel} subscription status: ${status}`, 'log');
    
    if (status === 'SUBSCRIBED') {
      throttledLog('subscription-success', `Successfully subscribed to ${channel}`, 'log');
      setConnectionStatus('OPEN');
      dispatchBreaker({ type: 'SUCCESS' });
    } else if (status === 'CLOSED' || status === 'CHANNEL_ERROR') {
    } else if (status === 'CLOSED' || status === 'CHANNEL_ERROR') {
      throttledLog('subscription-error', `Subscription to ${channel} error or closed: ${status}`, 'warn');
      setConnectionStatus('CLOSED');
      
      // Dispatch failure to circuit breaker
      dispatchBreaker({ type: 'FAIL' });
      
      // Schedule reconnect based on circuit breaker state
      scheduleReconnect();
    }
  }, [scheduleReconnect, dispatchBreaker]);

  // Page visibility change handler
  const handleVisibilityChange = useCallback(() => {
    if (document.visibilityState === 'visible' && 
        connectionStatus !== 'OPEN' && 
        breaker !== 'OPEN') {
      
      throttledLog(
        'visibility-reconnect',
        'Page became visible and connection is closed - attempting to reconnect',
        'log'
      );
      
      // Reset reconnect attempts when page becomes visible
      dispatchBreaker({ type: 'RESET' });
      
      // Fetch conversations
      fetchConversations();
    }
  }, [connectionStatus, breaker, fetchConversations, dispatchBreaker]);

  // Set up visibility change listener
  useEffect(() => {
    document.addEventListener('visibilitychange', handleVisibilityChange);
    
    return () => {
      document.removeEventListener('visibilitychange', handleVisibilityChange);
    };
  }, [handleVisibilityChange]);

  // Set up ping to keep the connection alive
  useEffect(() => {
    // Only start the ping interval if the connection is OPEN and breaker is CLOSED
    if (connectionStatus === 'OPEN' && breaker === 'CLOSED') {
      pingIntervalRef.current = setInterval(sendPing, WEBSOCKET_PING_INTERVAL);
      
      throttledLog('ping-started', 'Started ping interval to keep connection alive', 'log');
    } else if (pingIntervalRef.current) {
      // Clear the interval if the connection is not open
      clearInterval(pingIntervalRef.current);
      pingIntervalRef.current = null;
      
      throttledLog('ping-stopped', 'Stopped ping interval due to connection state change', 'log');
    }
    
    return () => {
      if (pingIntervalRef.current) {
        clearInterval(pingIntervalRef.current);
        pingIntervalRef.current = null;
      }
    };
  }, [connectionStatus, breaker, sendPing]);

  // Reset circuit breaker from OPEN to HALF_OPEN after timeout
  useEffect(() => {
    if (breaker === 'OPEN' && lastFailureTime) {
      // Clear any existing timeout
      if (breakerTimeoutRef.current) {
        clearTimeout(breakerTimeoutRef.current);
      }
      
      // Set timeout to transition from OPEN to HALF_OPEN
      breakerTimeoutRef.current = setTimeout(() => {
        throttledLog('breaker-half-open', 'Circuit breaker transitioning from OPEN to HALF_OPEN', 'log');
        dispatchBreaker({ type: 'HALF_OPEN' });
        breakerTimeoutRef.current = null;
      }, CIRCUIT_BREAKER_RESET_TIMEOUT);
      
      return () => {
        if (breakerTimeoutRef.current) {
          clearTimeout(breakerTimeoutRef.current);
          breakerTimeoutRef.current = null;
        }
      };
    }
  }, [breaker, lastFailureTime, dispatchBreaker]);

  // Main effect for subscription setup and cleanup
  useEffect(() => {
    // Set up subscriptions
    if (user && supabase && breaker !== 'OPEN') {
      fetchConversations();
    }
    
    // Cleanup function
    return () => {
      // Clean up all timeouts and intervals
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
        timeoutRef.current = null;
      }
      
      if (pingIntervalRef.current) {
        clearInterval(pingIntervalRef.current);
        pingIntervalRef.current = null;
      }
      
      if (breakerTimeoutRef.current) {
        clearTimeout(breakerTimeoutRef.current);
        breakerTimeoutRef.current = null;
      }
      
      // Unsubscribe from all subscriptions
      Object.values(subscriptionsRef.current).forEach(subscription => {
        if (subscription && typeof subscription.unsubscribe === 'function') {
          subscription.unsubscribe();
        }
      });
      
      // Clear subscriptions object
      subscriptionsRef.current = {};
    };
  }, [user, breaker, fetchConversations]);

  // Improved findUserByEmail function with direct database query
  const findUserByEmail = async (email: string): Promise<{id: string, email: string} | null> => {
    // Usar o utilitário centralizado para validação e normalização
    if (!email || !isValidEmail(email)) {
      toast({
        variant: "destructive",
        title: "Email inválido",
        description: "Por favor, forneça um email válido e completo",
      });
      return null;
    }
    
    try {
      // Normalizar o email para garantir consistência
      const normalizedEmail = normalizeEmail(email);
      console.log("Buscando usuário com email normalizado:", normalizedEmail);
      
      // Buscar diretamente da tabela profiles com email normalizado
      const { data: profiles, error } = await supabase
        .from('profiles')
        .select('id, email')
        .eq('email', normalizedEmail)
        .limit(1);
      
      if (error) {
        console.error("Erro ao buscar perfil:", error);
        throw error;
      }
      
      console.log("Resultado da consulta:", profiles);
      
      if (profiles && profiles.length > 0) {
        console.log("Usuário encontrado:", profiles[0]);
        
        // Garantir que não estamos retornando um falso positivo
        const foundEmail = profiles[0].email;
        const inputNormalized = normalizeEmail(email);
        const foundNormalized = normalizeEmail(foundEmail);
        
        if (foundNormalized !== inputNormalized) {
          console.warn(`Inconsistência na normalização: input=${inputNormalized}, found=${foundNormalized}`);
          
          toast({
            variant: "destructive",
            title: "Correspondência inexata",
            description: `O email "${profiles[0].email}" foi encontrado, mas você digitou "${email}"`,
          });
        }
        
        return {
          id: profiles[0].id,
          email: profiles[0].email
        };
      }
      
      // Se não encontrar nada, tentar uma busca mais ampla com ilike (apenas para diagnóstico)
      console.log("Tentando busca alternativa para diagnóstico...");
      const { data: likeProfiles, error: likeError } = await supabase
        .from('profiles')
        .select('id, email')
        .eq('email', `%${email.split('@')[1]}%`) // Apenas para encontrar domínios similares
        .limit(5);
      
      if (!likeError && likeProfiles && likeProfiles.length > 0) {
        console.log("Domínios similares encontrados (apenas para diagnóstico):", 
          likeProfiles.map(p => p.email));
      }
      
      console.log("Nenhum usuário encontrado com o email:", email);
      toast({
        variant: "destructive",
        title: "Usuário não encontrado",
        description: "Não foi possível encontrar um usuário com esse email exato",
      });
      return null;
      
    } catch (err) {
      console.error('Exceção ao buscar usuário por email:', err);
      toast({
        variant: "destructive",
        title: "Erro ao buscar usuário",
        description: "Ocorreu um erro ao buscar o usuário. Tente novamente."
      });
      return null;
    }
  };

  const createConversation = async (participantIds: string[]) => {
    try {
      if (!user) throw new Error("User not authenticated");
      
      console.log("Creating conversation with participants:", participantIds);
      
      // Create new conversation with a valid UUID
      const conversationId = uuidv4();
      
      // First, insert the conversation record
      const { data: newConversation, error: conversationError } = await supabase
        .from('conversations')
        .insert({ 
          id: conversationId,
          name: null 
        })
        .select()
        .single();
          
      if (conversationError) {
        console.error("Error creating conversation:", conversationError);
        throw conversationError;
      }
      
      console.log("Created new conversation:", newConversation);
      
      // Add the current user as a participant first
      const { error: currentUserError } = await supabase
        .from('conversation_participants')
        .insert({
          conversation_id: newConversation.id,
          user_id: user.id
        });
        
      if (currentUserError) {
        console.error(`Error adding current user as participant:`, currentUserError);
        throw currentUserError;
      }
      
      // Now that the current user is a participant, add other participants
      for (const participantId of participantIds) {
        if (participantId === user.id) continue; // Skip if it's the current user
        
        const { error: participantError } = await supabase
          .from('conversation_participants')
          .insert({
            conversation_id: newConversation.id,
            user_id: participantId
          });
            
        if (participantError) {
          console.error(`Error adding participant ${participantId}:`, participantError);
          toast({
            variant: "destructive",
            title: "Erro ao adicionar participante",
            description: "Um participante não pôde ser adicionado à conversa",
          });
          // Continue with other participants even if one fails
        }
      }
      
      // Refresh conversations list
      fetchConversations();
      
      toast({
        title: "Conversa criada com sucesso",
      });
      
      return newConversation.id;
    } catch (error) {
      console.error('Error creating conversation:', error);
      const errorMessage = error instanceof Error ? error.message : "Não foi possível criar a conversa";
      toast({
        variant: "destructive",
        title: "Erro ao criar conversa",
        description: errorMessage,
      });
      throw error;
    }
  };

  // Função para marcar uma conversa como excluída para o usuário atual
  const deleteConversation = async (conversationId: string) => {
    if (!conversationId || !user) {
      console.error(`[useConversations] Cannot delete conversation: ${!conversationId ? 'missing conversationId' : 'user not authenticated'}`);
      return false;
    }
    
    try {
      console.log(`[useConversations] Marking conversation ${conversationId} as deleted for user ${user.id}`);
      
      // 1. Atualizar o estado local imediatamente (update otimista)
      setConversations(prevConversations => 
        prevConversations.filter(conv => conv.id !== conversationId)
      );
      
      // 2. Chamar a função SQL que marca a conversa como excluída só para este usuário
      console.log(`[useConversations] Calling mark_conversation_deleted RPC with conversationId: ${conversationId}`);
      
      // Check if the RPC function exists first
      try {
        // Log the conversationId to ensure it has the expected format
        console.log("[useConversations] Conversation ID type:", typeof conversationId);
        console.log("[useConversations] Conversation ID value:", conversationId);
        
        // Alternative implementation using direct table operations if the RPC fails
        const { data, error } = await callRPC<boolean>('mark_conversation_deleted', {
            p_conversation_id: conversationId,
          });
          
        if (error) {
          console.error("[useConversations] RPC Error marking conversation as deleted:", error);
          
          // Fallback to direct table operations if RPC function doesn't exist
          console.log("[useConversations] Falling back to direct table operations");
          
          // First check if preference already exists
          const { data: existingPrefs, error: prefsError } = await fromTable<UserConversationPreference>('user_conversation_preferences')
            .select('*')
            .eq('user_id', user.id)
            .eq('conversation_id', conversationId)
            .maybeSingle();
            
          if (prefsError) {
            console.error("[useConversations] Error checking existing preferences:", prefsError);
            throw prefsError;
          }
          
          if (existingPrefs) {
            // Update existing preference
            console.log("[useConversations] Updating existing preference");
            const { error: updateError } = await fromTable<UserConversationPreference>('user_conversation_preferences')
              .update({ 
                is_deleted: true,
                updated_at: new Date().toISOString()
              })
              .eq('id', existingPrefs && 'id' in existingPrefs ? existingPrefs.id : '');
              
            if (updateError) {
              console.error("[useConversations] Error updating preference:", updateError);
              throw updateError;
            }
          } else {
            // Create new preference
            console.log("[useConversations] Creating new preference");
            const { error: insertError } = await fromTable<UserConversationPreference>('user_conversation_preferences')
              .insert({ 
                user_id: user.id, 
                conversation_id: conversationId, 
                is_deleted: true,
                is_muted: false,
                is_pinned: false,
                is_archived: false,
                created_at: new Date().toISOString(),
                updated_at: new Date().toISOString()
              } as Database['public']['Tables']['user_conversation_preferences']['Insert']);
              
            if (insertError) {
              console.error("[useConversations] Error inserting preference:", insertError);
              throw insertError;
            }
          }
        } else {
          console.log("[useConversations] RPC call successful:", data);
        }
      } catch (rpcError) {
        console.error("[useConversations] Exception during RPC or fallback:", rpcError);
        // Reverter a atualização otimista em caso de erro
        fetchConversations(); // Restaurar estado original
        throw rpcError;
      }
      
      // 3. Sucesso - não precisamos refetch total pois já atualizamos otimisticamente
      console.log("[useConversations] Successfully marked conversation as deleted");
      
      return true;
    } catch (error) {
      console.error('Erro ao excluir conversa:', error);
      const errorMessage = error instanceof Error ? error.message : "Não foi possível excluir a conversa";
      toast({
        variant: "destructive",
        title: "Erro ao excluir conversa",
        description: errorMessage,
      });
      return false;
    }
  };

  // Função para marcar as mensagens de uma conversa como limpas para o usuário atual
  const clearMessages = async (conversationId: string) => {
    if (!conversationId || !user) return false;
    
    try {
      console.log(`[useConversations] Marking messages as cleared for conversation ${conversationId} user ${user.id}`);
      
      // 1. Atualizar o estado local imediatamente (update otimista)
      setConversations(prevConversations => 
        prevConversations.map(conv => {
          if (conv.id === conversationId) {
            return {
              ...conv,
              last_message: null,
              last_message_time: null,
              lastMessage: undefined
            };
          }
          return conv;
        })
      );
      
      // 2. Chamar a função SQL que marca as mensagens como limpas só para este usuário
      console.log(`[useConversations] Calling mark_messages_cleared RPC with conversationId: ${conversationId}`);
      
      // Check if the RPC function exists first
      try {
        // Log the conversation ID to ensure it has the expected format
        console.log("[useConversations] Conversation ID type:", typeof conversationId);
        console.log("[useConversations] Conversation ID value:", conversationId);
        
        // Call the RPC function to mark messages as cleared
        const { data, error } = await callRPC<boolean>('mark_messages_cleared', {
            p_conversation_id: conversationId
          });
          
        if (error) {
          console.error("[useConversations] RPC Error marking messages as cleared:", error);
          
          // Fallback to direct table operations if RPC function doesn't exist
          console.log("[useConversations] Falling back to direct table operations");
          
          const currentTimestamp = new Date().toISOString();
          
          // First check if preference already exists
          const { data: existingPrefs, error: prefsError } = await fromTable<UserConversationPreference>('user_conversation_preferences')
            .select('*')
            .eq('user_id', user.id)
            .eq('conversation_id', conversationId)
            .maybeSingle();
            
          if (prefsError) {
            console.error("[useConversations] Error checking existing preferences:", prefsError);
            throw prefsError;
          }
          
          if (existingPrefs) {
            // Update existing preference
            console.log("[useConversations] Updating existing preference with messages_cleared_at");
            const { error: updateError } = await fromTable<UserConversationPreference>('user_conversation_preferences')
              .update({ 
                messages_cleared_at: currentTimestamp,
                updated_at: currentTimestamp
              })
              .eq('id', existingPrefs && 'id' in existingPrefs ? existingPrefs.id : '');
              
            if (updateError) {
              console.error("[useConversations] Error updating preference:", updateError);
              throw updateError;
            }
          } else {
            // Create new preference
            console.log("[useConversations] Creating new preference with messages_cleared_at");
            // Create preference data object
            const preferenceData: Database['public']['Tables']['user_conversation_preferences']['Insert'] = {
                user_id: user.id,
                conversation_id: conversationId,
                messages_cleared_at: currentTimestamp,
                is_muted: false,
                is_pinned: false,
                is_archived: false,
                is_deleted: false,
                created_at: currentTimestamp,
                updated_at: currentTimestamp
            };
            
            const { error: insertError } = await fromTable<UserConversationPreference>('user_conversation_preferences')
              .insert(preferenceData);
              
            if (insertError) {
              console.error("[useConversations] Error inserting preference:", insertError);
              throw insertError;
            }
          }
        } else {
          console.log("[useConversations] RPC call successful:", data);
        }
      } catch (rpcError) {
        console.error("[useConversations] Exception during RPC or fallback:", rpcError);
        // Reverter a atualização otimista em caso de erro
        fetchConversations(); // Restaurar estado original
        throw rpcError;
      }
      
      // 3. Sucesso - não precisamos refetch total pois já atualizamos otimisticamente
      console.log("[useConversations] Successfully marked messages as cleared");
      
      return true;
    } catch (error) {
      console.error('Erro ao limpar mensagens:', error);
      const errorMessage = error instanceof Error ? error.message : "Não foi possível limpar as mensagens";
      toast({
        variant: "destructive",
        title: "Erro ao limpar mensagens",
        description: errorMessage,
      });
      return false;
    }
  };

  // Função para arquivar uma conversa só para o usuário atual
  const archiveConversation = async (conversationId: string) => {
    if (!conversationId || !user) return false;
    
    try {
      console.log(`[useConversations] Archiving conversation ${conversationId} for user ${user.id}`);
      
      // 1. Atualizar o estado local imediatamente (update otimista)
      setConversations(prevConversations => 
        prevConversations.map(conv => {
          if (conv.id === conversationId) {
            return {
              ...conv,
              is_archived: true
            };
          }
          return conv;
        })
      );
      
      // 2. Chamar a função SQL que arquiva a conversa só para este usuário
      console.log(`[useConversations] Calling set_conversation_archived RPC with conversationId: ${conversationId}`);
      
      // Check if the RPC function exists first
      try {
        // Alternative implementation using direct table operations if the RPC fails
        const { data, error } = await callRPC<boolean>('set_conversation_archived', {
            p_conversation_id: conversationId,
            p_is_archived: true
          });
          
        if (error) {
          console.error("[useConversations] RPC Error archiving conversation:", error);
          
          // Fallback to direct table operations if RPC function doesn't exist
          console.log("[useConversations] Falling back to direct table operations");
          
          // First check if preference already exists
          const { data: existingPrefs, error: prefsError } = await fromTable<UserConversationPreference>('user_conversation_preferences')
            .select('*')
            .eq('user_id', user.id)
            .eq('conversation_id', conversationId)
            .maybeSingle();
            
          if (prefsError) {
            console.error("[useConversations] Error checking existing preferences:", prefsError);
            throw prefsError;
          }
          
          if (existingPrefs) {
            // Update existing preference
            console.log("[useConversations] Updating existing preference to archived");
            const { error: updateError } = await fromTable<UserConversationPreference>('user_conversation_preferences')
              .update({ 
                is_archived: true,
                updated_at: new Date().toISOString()
              })
              .eq('id', existingPrefs && 'id' in existingPrefs ? existingPrefs.id : '');
              
            if (updateError) {
              console.error("[useConversations] Error updating preference:", updateError);
              throw updateError;
            }
          } else {
            // Create new preference
            console.log("[useConversations] Creating new preference with archived");
// Use Database type to define the insert structure
const preferenceData: Database['public']['Tables']['user_conversation_preferences']['Insert'] = {
                user_id: user.id, 
                conversation_id: conversationId, 
                is_archived: true,
                is_muted: false,
                is_pinned: false,
                is_deleted: false,
                created_at: new Date().toISOString(),
                updated_at: new Date().toISOString()
              };
              
const { error: insertError } = await fromTable<UserConversationPreference>('user_conversation_preferences')
              .insert(preferenceData);
              
            if (insertError) {
              console.error("[useConversations] Error inserting preference:", insertError);
              throw insertError;
            }
          }
        } else {
          console.log("[useConversations] RPC call successful:", data);
        }
      } catch (rpcError) {
        console.error("[useConversations] Exception during RPC or fallback:", rpcError);
        // Reverter a atualização otimista em caso de erro
        fetchConversations(); // Restaurar estado original
        throw rpcError;
      }
      
      // 3. Não precisamos refetch total pois já atualizamos otimisticamente
      console.log("[useConversations] Successfully archived conversation");
      
      return true;
    } catch (error) {
      console.error('Erro ao arquivar conversa:', error);
      const errorMessage = error instanceof Error ? error.message : "Não foi possível arquivar a conversa";
      toast({
        variant: "destructive",
        title: "Erro ao arquivar conversa",
        description: errorMessage,
      });
      return false;
    }
  };

  // Função para silenciar uma conversa só para o usuário atual
  const muteConversation = async (conversationId: string) => {
    if (!conversationId || !user) return false;
    
    try {
      console.log(`[useConversations] Muting conversation ${conversationId} for user ${user.id}`);
      
      // 1. Atualizar o estado local imediatamente (update otimista)
      setConversations(prevConversations => 
        prevConversations.map(conv => {
          if (conv.id === conversationId) {
            return {
              ...conv,
              is_muted: true
            };
          }
          return conv;
        })
      );
      
      // 2. Chamar a função SQL que silencia a conversa só para este usuário
      const { data, error } = await callRPC<boolean>('set_conversation_muted', {
          p_conversation_id: conversationId,
          p_is_muted: true
        });
        
      if (error) {
        // Reverter a atualização otimista em caso de erro
        console.error("[useConversations] Error muting conversation:", error);
        fetchConversations(); // Restaurar estado original
        throw error;
      }
      
      // 3. Não precisamos refetch total pois já atualizamos otimisticamente
      console.log("[useConversations] Successfully muted conversation");
      
      return true;
    } catch (error) {
      console.error('Erro ao silenciar conversa:', error);
      const errorMessage = error instanceof Error ? error.message : "Não foi possível silenciar a conversa";
      toast({
        variant: "destructive",
        title: "Erro ao silenciar conversa",
        description: errorMessage,
      });
      return false;
    }
  };

  // Função para fixar uma conversa só para o usuário atual
  const pinConversation = async (conversationId: string) => {
    if (!conversationId || !user) return false;
    
    try {
      console.log(`[useConversations] Pinning conversation ${conversationId} for user ${user.id}`);
      
      // 1. Atualizar o estado local imediatamente (update otimista)
      setConversations(prevConversations => 
        prevConversations.map(conv => {
          if (conv.id === conversationId) {
            return {
              ...conv,
              is_pinned: true
            };
          }
          return conv;
        })
      );
      
      // 2. Chamar a função SQL que fixa a conversa só para este usuário
      const { data, error } = await callRPC<boolean>('set_conversation_pinned', {
          p_conversation_id: conversationId,
          p_is_pinned: true
        });
        
      if (error) {
        // Reverter a atualização otimista em caso de erro
        console.error("[useConversations] Error pinning conversation:", error);
        fetchConversations(); // Restaurar estado original
        throw error;
      }
      
      // 3. Não precisamos refetch total pois já atualizamos otimisticamente
      console.log("[useConversations] Successfully pinned conversation");
      
      return true;
    } catch (error) {
      console.error('Erro ao fixar conversa:', error);
      const errorMessage = error instanceof Error ? error.message : "Não foi possível fixar a conversa";
      toast({
        variant: "destructive",
        title: "Erro ao fixar conversa",
        description: errorMessage,
      });
      return false;
    }
  };

  return { 
    conversations, 
    loading, 
    createConversation,
    deleteConversation,
    clearMessages,
    archiveConversation,
    muteConversation,
    pinConversation,
    refreshConversations: fetchConversations,
    findUserByEmail
  };
};
